async function loadData(keepZoom = false) {
    const btn = document.getElementById('refreshBtn');
    const oldText = btn.innerText;
    btn.innerText = "TÖLTÉS...";
    
    const dateStr = document.getElementById('datePicker').value;
    const [year, month, day] = dateStr.split('-').map(Number);
    
    // A cél nap határai helyi idő szerint (ms-ban)
    const localStart = new Date(year, month - 1, day, 0, 0, 0).getTime();
    const localEnd = new Date(year, month - 1, day, 23, 59, 59).getTime();

    // 3-3 órás biztonsági puffer az URL-ben (3 * 60 * 60 * 1000 ms)
    const bufferMs = 3 * 60 * 60 * 1000;
    const queryStart = new Date(localStart - bufferMs).toISOString();
    const queryEnd = new Date(localEnd + bufferMs).toISOString();

    const url = `https://api.thingspeak.com/channels/${CHAN_ID}/fields/1.json?api_key=${API_KEY}&start=${queryStart}&end=${queryEnd}`;

    try {
        const response = await fetch(url);
        const data = await response.json();
        
        // Feldolgozás: ISO idő konvertálása helyi időre, majd szűrés a 0-24 órás sávra
        const feeds = data.feeds.map(f => ({
            x: new Date(f.created_at).getTime(), 
            y: parseFloat(f.field1)
        }))
        .filter(f => !isNaN(f.y) && f.x >= localStart && f.x <= localEnd);

        const gradients = [];
        if (feeds.length > 0) {
            // ... (statisztikák és grádiens számítása változatlan)
            const windowMs = 5 * 60 * 1000;
            feeds.forEach((curr) => {
                const past = feeds.find(f => f.x >= curr.x - windowMs && f.x < curr.x);
                gradients.push(past ? (curr.y - past.y) / ((curr.x - past.x) / 60000) : 0);
            });

            document.getElementById('statMax').innerText = Math.max(...feeds.map(f => f.y)).toFixed(1);
            document.getElementById('statMin').innerText = Math.min(...feeds.map(f => f.y)).toFixed(1);
            document.getElementById('statLast').innerText = feeds[feeds.length-1].y.toFixed(1);
            document.getElementById('gradMax').innerText = Math.max(...gradients).toFixed(2);
            document.getElementById('gradMin').innerText = Math.min(...gradients).toFixed(2);
            document.getElementById('gradLast').innerText = gradients[gradients.length-1].toFixed(2);

            myChart.data.datasets[0].data = feeds;
            myChart.data.datasets[0].gradients = gradients;
        } else {
            myChart.data.datasets[0].data = [];
        }

        // Fixáljuk a skálát a helyi nap határaihoz
        myChart.options.scales.x.min = localStart;
        myChart.options.scales.x.max = localEnd;
        myChart.options.plugins.zoom.limits.x.min = localStart;
        myChart.options.plugins.zoom.limits.x.max = localEnd;

        if (!keepZoom) myChart.resetZoom();
        myChart.update('none');
    } catch (e) { 
        console.error("Hiba:", e); 
    } finally { 
        btn.innerText = oldText; 
    }
}
